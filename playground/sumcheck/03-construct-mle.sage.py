

# This file was *autogenerated* from the file 03-construct-mle.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)# Return the list of eq(r, b) for all b in {0,1}^n, ordered by b's binary value
# r: sequence (r0,...,r_{n-1}) of field elements

def all_eq_weights_at_point(r):
    n = len(r)
    # constants per coordinate
    factors = [(_sage_const_1  - r[i], r[i]) for i in range(n)]  # (a_i, b_i)
    weights = [_sage_const_1 ]
    for (ai, bi) in factors:
        new = []
        for w in weights:
            new.append(w * ai)  # bit = 0 branch
            new.append(w * bi)  # bit = 1 branch
        weights = new
    return weights  # length 2^n

# Optional: map to a dict keyed by Boolean tuples
def all_eq_weights_dict(r):
    ws = all_eq_weights_at_point(r)
    n = len(r)
    table = {}
    for idx, w in enumerate(ws):
        b = tuple((idx >> k) & _sage_const_1  for k in range(n))
        table[b[::-_sage_const_1 ]] = w
    return table



# f is either:
#  - a dict mapping Boolean tuples to field elements, or
#  - a polynomial already evaluable on {0,1}^n
# Returns a multilinear polynomial in the appropriate ring

def multilinear_extension(f):
    if isinstance(f, dict):
        F = list(f.values())[_sage_const_0 ].base_ring()
        variables = [f"x{i+_sage_const_1 }" for i in range(len(next(iter(f.keys()))))]
    else:
        F = f.base_ring()
        variables = f.variables()
    R = PolynomialRing(F, variables)
    variables = R.gens()
    n = len(variables)
    if not isinstance(f, dict):
        f = R(f)
    eq_points = all_eq_weights_dict(variables)  # eq weights at point variables
    ext = _sage_const_0 
    for bits in product([_sage_const_0 , _sage_const_1 ], repeat=n):
        if isinstance(f, dict):
            val = f.get(bits, _sage_const_0 )
        else:
            val = f(*bits)
        # multiply by the Boolean Lagrange basis polynomial eq(Â·, bits)
        ext += R(val * eq_points[bits])
    # ensure ext.variables() == f.parent().gens() to permit calling 
    # f([r1,...,rn]) with n = len(f.variables())
    if len(ext.variables()) != n:
        R = PolynomialRing(ext.base_ring(), ext.variables())
        ext = R(ext)
    return ext

