# Efficient Sumcheck

Divides the `n` rounds of sumcheck into `k` stages. At the start of each stage, it performs a precomputation to populate a table of size O ( N 1 / k ) O(N 1/k ), which is then used to compute the polynomials related to that particular stage.

- git: https://github.com/compsec-epfl/efficient-sumcheck
- post: https://gfenzi.io/papers/blendy-sumcheck


## Papers
- [Verifying Computations with Streaming Interactive Proofs](https://arxiv.org/pdf/1109.6882) `Time O(NlogN) Space O(logN)`
- [A hybrid architecture for interactive verifiable computation](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6547112) `Time O(N) Space O(N)`
- [Time-Space Trade-Offs for Sumcheck](https://eprint.iacr.org/2025/1473.pdf)
- [A Time-Space Tradeoff for the Sumcheck Prover](https://eprint.iacr.org/2024/524.pdf) `Time O(kN) Space O(N^1/k)`
- [The Sum-Check Protocol over Fields of Small Characteristic](https://people.cs.georgetown.edu/jthaler/small-sumcheck.pdf)
- [Constraint-Packing and the Sum-Check Protocol over Binary Tower Fields](https://eprint.iacr.org/2024/1038.pdf)
- Slides
    - [Streaming IOP](https://people.cs.georgetown.edu/jthaler/CTYVLDB.pdf)
    - [Modern Verifiable Compute](https://people.cs.georgetown.edu/jthaler/summer-school-talk-08.pdf)


## Questions
- Blendy benchmark result generation steps mentioned in [blendy-sumcheck](https://gfenzi.io/papers/blendy-sumcheck/#fn:2), specifically memory
- Binary fields
  - https://www.ingonyama.com/authors/suyash-bagad
  - https://hackmd.io/@tcoratger/BklKeQ5Okl



- Intial bench `cargo bench`

```rust
sumcheck_prover/time_product_prover
                        time:   [1.1752 s 1.2156 s 1.2715 s]
                        change: [−8.0324% −1.8096% +4.8445%] (p = 0.61 > 0.05)

sumcheck_prover/time_prover
                        time:   [188.61 ms 191.41 ms 194.60 ms]
                        change: [−8.2645% −4.2945% −0.0554%] (p = 0.08 > 0.05)
```
