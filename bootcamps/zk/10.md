### Q&A on Sequencer, ZK Rollups, and Related Topics

**Q: What specifically does the sequencer do?**  
**A:** Orders, batches, and processes L2 transactions before posting to L1 for settlement.

**Q: Data availability serves L2 or L1?**  
**A:** Primarily L1, for verification and security; L2 computes and posts proofs.

**Q: What is a based rollup?**  
**A:** L2 scaling using Ethereum's block builders for sequencing, enhancing decentralization without centralized sequencers.

**Q: How does transaction optimization work?**  
**A:** Groups transactions, compresses data, removes unnecessary steps for cheaper, faster processing.

**Q: What specific value is zkSync providing?**  
**A:** Ease of creating Hyperchains for scalable, interconnected L2s.

**Q: Why does data availability serve L1 primarily? Doesn't L2 do heavy computation and post succinct proof to L1 for verification?**  
**A:** L1 ensures transaction data storage for public verification and security; L2 handles computation, L1 verifies proof and data.

**Q: How are AggLayer, OP Superchains, and zkSync Hyperchains different architecturally?**  
**A:** AggLayer unifies liquidity across ZK chains via shared bridges; OP Superchains focus on optimistic rollup interoperability; zkSync Hyperchains enable customizable ZK L2/L3 chains.

**Q: Is AggLayer some kind of ZK gateway to mainnet?**  
**A:** No, it's a unification layer for aggregated blockchains, enabling shared security and liquidity.

**Q: A sequencer orders, batches, and processes L2 transactions before posting to L1. Then what do searcher, proposer, builder, validators do?**  
**A:** Searcher: Finds MEV opportunities; Proposer/Builder: Not in AggLayer; Validators: Verify proofs on L1.

**Q: While L2 does most work with transactions, L1 keeps enough data to verify? Doesn't L1 only verify the proof?**  
**A:** L1 verifies proof and stores data for security, depending on rollup type.

**Q: What is calldata? Where is it stored? Not in world state, right?**  
**A:** Function arguments in transactions; stored in tx data/block, not world state.

**Q: What's the difference between esSNARKs and SNARKs?**  
**A:** esSNARKs unclear; zk-SNARKs are succinct non-interactive ZK proofs; possible typo for zk-SNARKs variants.

**Q: Benefit of EVM vs ZK-EVM is scalability via valid proof, privacy not guaranteed?**  
**A:** Yes, ZK-EVM provides scalability with proofs; privacy implementation-specific.

**Q: Do ZK-EVMs need more computing power? Do fees get higher than other L2s?**  
**A:** Yes, more compute leads to higher fees vs optimistic L2s, but offers security and fast finality.

**Q: Calldata is function arguments, not stored permanently, lives in tx data. Where is tx data stored?**  
**A:** In transactions within blocks on the blockchain.

**Q: eSTARKs vs STARKs?**  
**A:** eSTARKs extend STARKs with arguments for flexible constraints; STARKs are scalable transparent ZK proofs.

**Q: What do different circuits mean? Storage circuit, EVM?**  
**A:** Grouped by purpose: Storage for state updates, EVM for opcode execution.

**Q: Where can we find code for these circuits like ZK-M, RAM?**  
**A:** In zkSync-era repo: https://github.com/matter-labs/zksync-era.

**Q: Are circuits like smart contracts in Scroll?**  
**A:** No, circuits are core EVM/blockchain code for proofs.

**Q: What is execution trace and how related to proving in ZK?**  
**A:** Log of computation steps; ZK proves trace correctness.

**Q: Are we allowed to change project groups depending on ideas?**  
**A:** 99% yes, confirm with Encode team via Discord/email.

**Q: Is there a dump for execution trace of simple operation like addition?**  
**A:** Run program on CairoVM: https://www.cairo-lang.org/cairovm/ to generate trace.

**Q: Doesn't sAdd(1 - sAdd) always result in zero? Why check?**  
**A:** Enforces sAdd binary (0 or 1) for circuit security.

**Q: How GPU optimizes Halo2/KZG?**  
**A:** Leverages parallel processing for faster proof generation.

**Q: If Halo2 good on GPU? Which performs bad? Recursive? Groth16?**  
**A:** Halo2/Plonk good with GPU; Groth16 less optimized; recursion varies by framework.

**Q: All Ethereum blocks added to Taiko block and Taiko blockchain?**  
**A:** No, Taiko is based rollup settling on Ethereum.

**Q: Fastest ZKVM so far with GPU optimization, custom gates, lookup tables?**  
**A:** RISC Zero/SP1 Turbo lead in 2025 benchmarks; zkMIPS fastest on CPU/GPU.

**Q: What proving schemes does Kakarot use?**  
**A:** STARK-based via Cairo/Starknet.

**Q: Is Kakarot live? Apps building with it?**  
**A:** Live on Sepolia testnet; apps in development.

**Q: In Scroll, all EVM opcodes made into circuits?**  
**A:** Yes, each opcode translated to dedicated circuit.

**Q: Which proving scheme does Linea use? Edge over others?**  
**A:** Combines PIOPs, Wizard-IOP, Arcane, Vortex, PlonK for efficiency/flexibility.

### Resources
- https://docs.taiko.xyz/core-concepts/what-is-taiko
- https://blog.celer.network/2023/08/04/the-pantheon-of-zero-knowledge-proof-development-frameworks/
- https://www.cairo-lang.org/cairovm
- https://github.com/matter-labs/zksync-era
- https://docs.polygon.technology/zkEVM/concepts/generic-state-machine/exec-trace-correct
- https://github.com/0xPolygonHermez
- https://polygon.technology/blog/aggregated-blockchains-a-new-thesis
- https://www.halborn.com/blog/post/what-are-hyperchains-and-superchains-in-blockchain
- https://zksync.io