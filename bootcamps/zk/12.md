### Q&A on ZK Proofs, Polynomials, and Related Topics

**Q: Verifier knows the vanishing polynomials. Code is converted to polynomials through constraints? What is the need of execution trace then?**  
**A:** Execution trace evidences correct program run and constraint satisfaction.

**Q: Would the protocol deal with math for polynomials/constraints, or is it on application layer in Mina/O1 or RiscZero for privacy (some data private)?**  
**A:** In Mina/Risc0, computation creates trace as witness; private inputs enable privacy.

**Q: What is CRS doing in the deterministic part?**  
**A:** CRS provides structured reference strings for setup; ensures deterministic proof generation.

**Q: The 5*5=25 is trivial. For non-trivial example, how to generate circuits from application level? Is that the key part?**  
**A:** Use zk languages (e.g., Noir, Cairo) to define constraints; key for app logic to circuit translation.

**Q: For Mina, do we do proof generation on client side?**  
**A:** Yes.

**Q: Are constraints what verifier uses to verify, or only for prover?**  
**A:** Primarily for prover; verifier uses derived form in proof.

**Q: Are there ZK proofs without polynomial commitments? All need them/reductions?**  
**A:** Yes, e.g., Bulletproofs without polynomials; polynomials enable succinctness.

**Q: What are proofs without polynomials called?**  
**A:** Bulletproofs, for example.

**Q: As Web2 developer, focus to prove bank balance 5000-10000 USD? How to write high-level or circuit?**  
**A:** Define circuit constraints for range proof (e.g., via Plonk); witness is private balance.

**Q: If I prove 20 ETH sent to account, how verify proper context? Can't run own EVM version globally?**  
**A:** Global state transition proved via circuit; verifier checks against shared state root.

**Q: Is constraint defined by verifier or circuit?**  
**A:** Circuit defines constraints; verifier checks proof satisfaction.

**Q: Compare/contrast ZKPs and ZKML? Is ZKML just ZKP with private data/weights?**  
**A:** ZKML applies ZKPs to ML models; proves inferences with private weights/data. Covered next week.

**Q: Prover knows V(x), but doesn't know verifier's x, so can't cheat?**  
**A:** Yes.

**Q: Is this Random Oracle Model?**  
**A:** Not exactly.

**Q: In Fiat-Shamir, verifier doesn't supply x?**  
**A:** Correct; randomness from hash, no direct supply needed.

**Q: Impact of Fiat-Shamir on proof size?**  
**A:** Minimal impact.

**Q: Does verifier know the polynomial?**  
**A:** No, only commitments/evaluations.

**Q: If randomness compromised, whole system compromised?**  
**A:** Correct.

**Q: Prover doesn't evaluate V(x) at random x?**  
**A:** Prover commits to V; verifier challenges at random x.

**Q: Use VRF to prove random points picked?**  
**A:** Possible, but Fiat-Shamir uses hash for pseudo-randomness.

**Q: How ensure entropy of public inputs sufficient?**  
**A:** Via cryptographic hashes; Fiat-Shamir derives from transcript.

**Q: Go on vanishing polynomials? Points verifier knows evaluate to zero?**  
**A:** Yes; vanishing polys enforce constraints at specific points (e.g., domain roots).

**Q: How verifier know random point to calculate polynomial?**  
**A:** Derived via Fiat-Shamir from public transcript.

**Q: How verifier/prover agree without communication?**  
**A:** Fiat-Shamir: Hash prior messages for shared randomness.
