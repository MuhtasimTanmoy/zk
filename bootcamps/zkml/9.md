### Circuits, Proofs & Efficiency

**Q: How does a program turn into gate inputs, relations, or selectors?**<br/>
**A:** The program (e.g., an ML model or arithmetic expression) is compiled into a constraint system. Each operation (add, mul, etc.) maps to gates. Selectors indicate which operations are active, wiring inputs/outputs into relations enforced by the proof system.

**Q: If we are computing over the Boolean hypercube, then extending to multilinear extensions with inputs other than 0/1, how are random numbers used?**<br/>
**A:** Random challenges are sampled by the verifier. These challenges extend the Boolean hypercube evaluation to random field points, ensuring the prover can’t cheat without being caught with high probability.

**Q: What’s the difference between proof recursion, proof compression, and folding schemes?**<br/>
**A:**

* **Proof recursion** : Embedding one proof inside another, enabling scalable composition.
* **Proof compression** : Reducing size of a single proof (e.g., batching or succinct representation).
* **Folding schemes** : Incrementally combine multiple instances/proofs into a single one with algebraic folding.

**Q: Do we need to program these equations manually, or are they part of the EZKL library?**<br/>
**A:** They’re part of EZKL. The library handles circuit construction (selectors, constraints, equations) automatically when you compile an ONNX model.

**Q: Is the point of using selectors to keep the circuit smaller? Why are they more efficient?**<br/>
**A:** Yes. Selectors allow multiple operations to share a gate type by “turning on/off” constraints. This reduces circuit size and avoids redundant gates, leading to lower proving costs.

**Q: How would proofs on the inference stage help with copyright or other allegations, which relate to the training stage?**<br/>
**A:** They don’t solve training copyright issues directly. Inference proofs only show that a given model produced a specific output—useful for accountability, but training provenance remains a separate problem.

**Q: Isn’t bitwise arithmetic (e.g., Bloom filters) expensive in circuits? Don’t you need one field element per bit?**<br/>
**A:** Correct—bit decomposition is costly. Each bit must be represented as a constrained field element, making bitwise-heavy operations inefficient. Optimizations like lookup tables or custom gates can mitigate costs.
